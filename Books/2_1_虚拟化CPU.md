## 2.1
###虚拟化CPU

图示 2.1 描述了我们的第一个程序。它做的并不多，事实上，它所做的仅仅只是调用了一个被称为 *spin()* 的不断检查时间、运行一秒便立刻返回的函数。接着，它打印出用户之前在命令行中输入的字符串，并不断重复上述过程。

我们将这个程序储存为 *cpu.c* 并在拥有一个处理器（有时我们也将它称为 **CPU** ）的系统上编译和运行它。我们将看到如下情况：

```
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
A
ˆC prompt>
```

运行的过程并不是那么有趣——系统开始运行这个不断检查时间直到经过了一秒钟的程序。当一秒钟过去时，这串代码便将用户所输入的字符串打印出来（在这个例子中，是指字母“A”），并不断重复。注意喝个程序将不断运行，直到用户按下“Control-c”（在基于UNIX的系统上将终止正在前台运行的程序）后我们才能终止这个程序。

现在，让我们做一些同样的事。不过这一次，我们来运行这个相同程序的不同实例。图示2.2展示了这个稍稍更加复杂的例子。

```
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D & [1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
C
B
D
...
```

图示2.2 **在同一时间运行多个程序**

现在事情变得有一点点意思了。尽管我们只有一颗处理器，但不知为何所有的这四个程序似乎都在同一时间被运行了！这么奇妙的事情究竟是如何做到的？

事实证明，在硬件的帮助下，操作系统制造了这种**假象**(illusion)，即这个系统拥有大量真实 CPU 的假象。将一个 CPU 看起来上变成数量巨大的 CPU 并因此允许许多程序看起来可以在同时运行的技术被我们称作为**虚拟化 CPU**(virtualizing the CPU) ——这本书需要聚焦的第一个主题部分。

当然，去运行和停止这些程序，亦或者告诉操作系统哪些程序应该运行，你需要一些接口（APIs）去告诉系统你的需求。毫无疑问，它们是绝大多数用户与系统交流最主要的方式。

你或许也已经留意到了同时去运行多个程序的能力会引发各种各样的新问题。例如说，如果说两个程序都想在同一段特殊的时间运行，究竟应该运行哪一个？这个问题取决于操作系统的**政策**(policy)。在一个操作系统中政策被应用在许多不同的领域以便去回答这些各式各样的问题，因此我们将研究这些作为操作系统执行过程中的基本机制的内容（例如说同时运行多个程序的能力）。正因如此，错做系统充当了一个**资源管理器**(resource manager)的角色。

```
 1  #include <unistd.h>
 2  #include <stdio.h>
 3  #include <stdlib.h>
 4  #include "common.h"
 5  
 6  int
 7  main(int argc, char *argv[])
 8  {
 9      int *p = malloc(sizeof(int));            // a1
10      assert(p != NULL);
11      printf("(%d) address of p: %08x\n",    
12             getpid(), (unsigned) p);          // a2
13      *p=0;                                    // a3
14      while (1) {
15          Spin(1);
16          *p = *p + 1;
17          printf("(%d) p: %d\n", getpid(), *p); // a4
18      }
19      return 0;
20  }
```

图示2.3 **访问内存的一个程序**


