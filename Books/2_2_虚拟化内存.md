## 2.2 

## 虚拟化内存

现在让我们来考虑一下内存。使用现代机器设计的**物理内存**（physical memory）的模型非常简单。内存仅仅是一个字节所构成的数组，必须指定一个能够访问存储在哪里的数据的地址才能**读取**（read）内存，也必须指定一个要被写入所提供的内存的数据才能**写入**（write）或**更新**（update）内存。

在一个程序运行的过程中，内存无时无刻都在被访问着。程序将其所有的数据结构都储存在内存中，并通过各种各样的指令来访问它们，比如载入和储存，或其它当程序运行时所用来访问内存的显式指令。

我们来看看这个通过调用 *malloc()* 函数来分配内存的程序（如图示 2.3）。这个程序的输出如下所示：

```
prompt> ./mem
(2134) memory address of p: 00200000 
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
ˆC
```

这个程序做了许多的事。首先，它分配了一些内存（ *a1* 行）。接着，它打印出了内存的地址（ *a2* 行），而后将数字0放入了新分配内存的第一个内存插槽中（ *a3* 行）。最后，它循环、延迟了片刻并增加了在p保管的地址中所存储的值。在每个打印的语句中，它同时也打印出了运行的程序的进程标识符（ PID ）。在每个运行的程序中这个 PID 都是唯一的。

```
prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) memory address of p: 00200000 
(24114) memory address of p: 00200000 
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
...
```

图示2.4 **多次运行内存的程序**

又一次，第一个结果并不是非常的有趣。新分配的内存在地址 00200000。当程序运行时，它缓慢的更新着数值并将结果打印出来。

现在，我们再一次运行同一程序的多个实例来看看会发生什么（图示 2.4）。我们发现这个例子中每个运行的程序都将内存分配到了相同的地址（00200000），接着每个都似乎单独的更新着 00200000 中的值。

没错，操作系统在这所发生的确实就是**虚拟化内存**（virtualizing memory）。每个进程访问它自己私密的**虚拟内存空间**（virtual address space），有时我们将其简称为**内存空间**（virtual address space）——操作系统再以某种方式将其映射到机器的物理内存上。一个运行程序中所使用的内存不会影响到其它进程（或是系统本身）的地址空间。对于运行的程序而言，它所拥有的物理内存独属于它自身。尽管如此，事实上物理内存是一个由操作系统所管理的共享资源。具体这些事是如何完成的也是本书以**虚拟化**（virtualization）为题目的第一部分的主题所在。

