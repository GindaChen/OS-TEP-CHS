## 2

### 操作系统概论

如果你正在上一门操作系统的本科课程，你应该已经对计算机程序在运行时的究竟做了什么有了一定的了解。如果没有，这本书（以及其相应的课程）对你来说将会非常困难——因此你也许应该停止阅读这本书，或者跑到最近的书店，在继续阅读前快速的掌握必要的背景知识。（由 Patt 和 Patel 所著的[PP03]，特别是由 Bryant 与 O’Hallaron 合著的[BOH10]都是极好的书）。

所以，当一个程序运行时究竟发生了什么呢？

嗯，运行的程序仅仅做了一件非常简单的事：它在执行指令。处理器每秒钟从内存中**获取**（fetches）着着数百万（现在甚至数十亿）条指令，**解码**（decodes）它（即找出它对应的指令），并**执行**（executes）指令（即做应该做的事，比如说两数求和、访问内存、检查条件、跳转到某个函数等等）。当它执行完这条指令后，处理器便跳转到下一条指令…直到程序执行彻底完成。

因此，我们刚刚描述了**冯·诺依曼**（Von Neumann）计算模型的基础。听起来很简单对吗？但是在这个课堂上，我们将了解到当一个程序运行时，还有许多令人激动的事情正在进行，他们的主要目的是让系统更加的**易用**（easy to use）。

事实上，有一个软件负责使程序更加容易的运行（甚至允许您在表面上同时运行许多程序），允许程序去共享内存，允许程序与设备进行交互和其他许许多多的类似的有趣的事。这个软件叫做**操作系统**（operating system, OS），它作为负责确保系统以易于使用的方式正确和高效的运行。

> 核心问题：如何去虚拟化资源（virtualize resources）
> 
> 在本书中我们将回答的一个核心问题非常简单：操作系统是如何> 虚拟化资源的呢？这是我们问题的核心。为什么操作系统会这样做并不是主要的问题，因为答案应该是显而易见的：它使得系统更易用。因此，我们所关注的重点是：操作系统实现虚拟化的机制和策略是什么？操作系统为何如此高效的运作的？又需要什么样的硬件的支持呢？
> 
> 我们将使用在诸如此类的阴影框中的“核心问题”来指出我们在构建操作系统时所试图解决的具体问题。因此，在某一个特定主题的注释中，你也许会找见一个或更多个要点来突出这个问题（没错，这个"更多个"是正确的）。当然，此章节中的细节会提供具体的解决方案，或至少是解决方案的影响因素。

操作系统做到此的主要方法是通过一个我们将其称为**虚拟化**（virtualization）的通用技术。也就是，操作系统接受一个**物理**（physical）资源（比如说处理器、内存或是硬盘），并将其转化为一种对其来说更简单、更强大和更易用的一种**虚拟**（virtual）形式。正因如此，我们有时也将操作系统称作**虚拟机**（virtual machine）。

当然，为了使用户告诉操作系统应该做什么从而利用虚拟机的特性（比方说运行一个程序，或分配内存，亦或者访问一个文件），操作系统也提供一些供你调用的接口（APIs）。事实上一个典型的操作系统，能够导出几百个供应用使用的**系统调用**（system calls）。正因为操作系统提供这些系统调用去运行程序、访问内存和设备以及其它相关的行为，我们偶尔也说操作系统为应用程序提供了一个**标准库**（standard library）。

最后，因为虚拟化允许许多程序同时去运行（因此会分享CPU），也允许许多程序同时访问自己的结构和数据（因此会共享内存），还允许许多软件同时访问设备（因此会共享硬盘等等），所以操作系统偶尔也会被称为**资源管理器**（resource manager）。不论是CPU，内存还是硬盘都是系统的一种**资源**（resource）。因此，操作系统的指责便是去以高效、公平或其它可能的方法去**管理**（manage）这些资源。若想更加了解操作系统的指责，我们来看一下下面这个例子：

```
 1   #include <stdio.h>
 2   #include <stdlib.h>
 3   #include <sys/time.h>
 4   #include <assert.h>
 5   #include "common.h"
 6
 7   int
 8   main(int argc, char *argv[])
 9   {
10      if (argc != 2) {
11          fprintf(stderr, "usage: cpu <string>\n");
12          exit(1);
13      }
14      char *str = argv[1];
15      while (1) {
16          Spin(1);
17          printf("%s\n", str);
18      }
19      return 0;
20   }
```
图表 2.1 简单示例：循环与打印的代码


